Вариант 8

 

1.Разработать класс "кости домино" в соответствии со следующим заданием:

Состояние класса -

Массив костей домино описывается состояниями (“очками”) определенного числа костей (например, от 1 до 28) в группе. Для описания кости целесообразно использовать структуру. Память под массив костей выделяется статически, во время компиляции, и задается массивом фиксированного размера. В массиве костей не может быть одинаковых костей.

Протокол класса -

Определяет  возможности создания и инициализации экземпляров класса и правила их использования (методы класса).

Предусмотреть следующие возможности:

·          пустой конструктор для инициализации экземпляров и массивов экземпляров класса по умолчанию;

·          создание экземпляров класса с инициализацией количеством костей, значения которых определяются с помощью генератора случайных чисел;

·          создание экземпляров класса с инициализацией начальным состоянием одной кости с разными частями;

·          ввод экземпляров класса из входного потока и вывод в выходной поток;

·          добавить кость к группе, значение которой получается с помощью генератора случайных чисел;

·          изъять кость из группы (в операции участвует экземпляр класса с одной костью), если в группе есть такая кость;

·          “открыть” кость по её номеру в группе, создав экземпляр класса с одной костью;

·          упорядочить кости по возрастанию суммы очков;

·          выделить из группы костей подгруппу костей, содержащих конкретное значение хотя бы один раз.

2. Проектирование класса рекомендуется начать с представления состояния класса, учитывающего заданные операции, а затем реализации конструкторов и метода вывода. Для отладки и исчерпывающего тестирования других методов разработанного класса реализовать диалоговую программу, которая позволяет вводить параметры отлаживаемых методов. Для обработки ошибочных ситуаций использовать механизм исключительных ситуаций.

3. Повторить разработку класса, реализовав отдельные методы (там, где это оправданно), перегруженными операторами. Состав перегруженных операторов целесообразно согласовать с преподавателем.

4. Еще раз повторить разработку класса при условии, что память под массив необходимой длины выделяется динамически, во время выполнения программы (с помощью оператора new; память задается указателем на char в состоянии класса). Для хранения данных в экземпляре класса не должна использоваться лишняя память.

Дополнить интерфейс класса следующими возможностями:

·          создание экземпляра класса с его инициализацией другим экземпляром класса (копирующий конструктор);

·          переопределение экземпляра класса (с помощью перегруженного оператора присваивания).
